## use tuple
定义tuple的方法，访问tuple元素的方法

```
val test_tuple = (1,"name")
println(test_tuple._1)
println(test_tuple._2)
```
tuple是不可变的，tuple不同于list，tuple可以包含不同类型的元素，当一个函数需要返回多个不同类型的值时可以考虑使用tuple。

tuple为什么不用和list同样的方式(0)来访问元素，以为apply方法通常会返回相同的数据类型，但是tuple里面包含不同的数据类型。还有tuple的下标是从1开始的不是从0开始。
## use the set and map
set和map scala都提供了两种：可变的和不可变的。默认是不可变的，要使用可变的需要导入可变的包路径。set和map的继承关系如下图. hashMap和此图类似
![image](http://images2015.cnblogs.com/blog/981815/201704/981815-20170418103807712-2120396671.png)
set和map的定义方法如下和list，array类似：

```
val set = Set("bill","nick")
set += "tack"   //对于不可变set += 相当于 set = set + "tack", 对于可变的相当于调用set.+= 方法
println(set.contains("nice") 

val treasureMap = Map(1 -> "bill", 2 -> "nick")
treasureMap += (3 -> "test")
println(treasuerMap(3)) 

```

## step 12 read lines from a file
一个例子从文件读取每一行，并打印出每一样的长度，且对格式的要求。

里面学习到了一个知识：函数作为参数的意义。如下：

```
//line为从文件中读取的内容的list。
val longestLine = line.reduceLeft((a,b) => if(a.length > b) a else b )
//reduceleft 可以接受一个函数作为参数，(a,b) => if(a.length > b) a else b 为一个函数，reduceleft会按照这个函数的规则去处理自己集合中前两个元素，作用后的结果再和下一个元素按照规则处理。
```

# class and Object
## class, fields and methods
class是object的blueprint，定义好class后可以通过new关键字创建一个object。

fields和method是class的member。

fields是asinstance的，即从一个class创建了两个类，改变一个类中field的值不会影响另外一个类的值。

把field定义为private的属性可以保持类的鲁棒性。field默认为public的，不需要定义field之前添加public 关键字。

虽然scala能识别方法的返回值类型，但是为了方便阅读以及调用者调用类，最好每个方法都明确标明返回值类型。

方法的参数都是val的，不能在方法内部改变参数的值

如果一个方法只有副作用(side effort)，这个方法就叫做procedure

## semicolon inference
scala不需要单独在表达式后面添加分号，scala可以自动区分。scala在下面三种情况会认为行末尾不是分号：
1. 以不合法的字符作为结尾，例如+；2：下一行的开始的字符不能作为一个开始的字符；3：行以圆括号，中括号等结尾。
## singleton objects
a singleton object 定义就像创建一个lei，但是不用new 关键字。

伴生对象是和class名称相同的object，两者必须在同一个scala文件中。两者可以相互访问对方的member。

一个singleton和class不同的地方是object不能传递参数在初始化的时候，singleton是第一个初始化的。

## scala application
acala application不同于scala script。application要以一个main方法为入口的Object。scala中.scala文件的名字可以和文件里面的类，object的名称不同，但是建议还是取相同的名称。  

## the app trait
object继承了App 可以写main方法，直接运行object

# Basic Type and Operation
## Basic type 
Short, Char, Int,Long, Double,Fload,String,Boolean,Byte范围和Java一样


## 5.9 operator precedence
操作符优先级。scala的操作符就是方法，scala如何判断方法的优先级，就是根据方法的名字，例如以* / 开头的方法高于以+ - 开头的方法。 如下表：

```
* / %
+ -
:=
!
< >
&^|
```
但是有一个例外就是已=为结尾的操作符低于其他操作符。例如：

```
a *= b + 2 
//等价于
a = a * (b + 2)
```
当同一个优先级的操作符一起出现时如何关联：做关联或者有关联。以：为结尾的是右关联，其他为左关联：
```
a * b * c 
//等价于
(a * b) * c
(a).*(b).*(c)

a ::: b ::: c
//等价于
a ::: (b ::: c)
(c).:::(b).:::(a)
```


# chapter 6 Functional Object
本章主要介绍定义Functional Obejct 包含：self reference, overriding, constructe method, checking preconditions, private variable, methods and operator and overloading.

## 6.1 the specification for rational calss
有理数类的特殊操作，+ - * /
## 6.2 construct a rational
类可以直接带参数， scala编译器会类中的非字段和方法的定义编译到主构造器中。
另外还介绍了immutable比mutable的好处。
## 6.4 checking preconditions
构造方法可以添加预置判断：

```
class Rational(n:Int, d:Int) {
  require(d != 0)

  println(s"created $n/$d")

  override def toString: String = n + "/" + d

}
```
## 6.5 adding fields
类的参数不能直接访问，是private的？
## 6.6 self references
自我引用：this. 和java中this相同表示当前对象。有一种情况下this不能省去：

```
max(that: Rational) = {
    if(this.lessThan(that)) that else this
}
```
第一个this可以省去，但是第二个不能省去
## 6.7 auxilirary constructions
出了主构造器，其他的构造器都叫auxiliary construction。auxiliary construction的定义中的第一个语句必须是调用其他的构造器，也就是this..作为第一个语句，所以最后都是调用主构造器，主构造器也是类的唯一入口。
## 6.8 private fields and methods
private的成员和方法只供类的内部调用
## 6.9 使用+ - * / 符号定义方法
## 6.10 标识符 没看明白后面复习
IDENTIFIERS IN SCALA
You have now seen the two most important ways to form an identifier in Scala: alphanumeric and
operator. Scala has very flexible rules for forming identifiers. Besides the two forms you have seen
there are also two others. All four forms of identifier formation are described in this section.
An alphanumeric identifier starts with a letter or underscore, which can be followed by further letters,
digits, or underscores. The `$' character also counts as a letter; however, it is reserved for identifiers
generated by the Scala compiler. Identifiers in user programs should not contain `$' characters, even
though it will compile; if they do, this might lead to name clashes with identifiers generated by the
Scala compiler.
Scala follows Java's convention of using camel-case[5] identifiers, such
as toString andHashSet. Although underscores are legal in identifiers, they are not used that often in
Scala programs, in part to be consistent with Java, but also because underscores have many other nonidentifier uses in Scala code. As a result, it is best to avoid identifiers like to_string,__init__, or name_.
Camel-case names of fields, method parameters, local variables, and functions should start with a lower
case letter, for example: length, flatMap, and s. Camel-case names of classes and traits should start with
an upper case letter, for example: BigInt, List, and UnbalancedTreeMap.[6]
Note
One consequence of using a trailing underscore in an identifier is that if you attempt, for example, to
write a declaration like this, "val name_: Int = 1", you'll get a compiler error. The compiler will think
you are trying to declare a val named "name_:". To get this to compile, you would need to insert an
extra space before the colon, as in: "val name_ : Int = 1".
One way in which Scala's conventions depart from Java's involves constant names. In Scala, the
word constant does not just mean val. Even though a val does remain constant after it is initialized, it is
still a variable. For example, method parameters are vals, but each time the method is called those vals
can hold different values. A constant is more permanent. For example, scala.math.Pi is defined to be the
double value closest to the real value of π, the ratio of a circle's circumference to its diameter. This
value is unlikely to change ever; thus, Pi is clearly a constant. You can also use constants to give names
to values that would otherwise bemagic numbers in your code: literal values with no explanation,
which in the worst case appear in multiple places. You may also want to define constants for use in
pattern matching, a use case that will be described in Section 15.2. In Java, the convention is to give
constants names that are all upper case, with underscores separating the words, such
as MAX_VALUE or PI. In Scala, the convention is merely that the first character should be upper case.
Thus, constants named in the Java style, such as X_OFFSET, will work as Scala constants, but the
Scala convention is to use camel case for constants, such as XOffset.
An operator identifier consists of one or more operator characters. Operator characters are printable
ASCII characters such as +, :, ?, ~ or #.[7] Here are some examples of operator identifiers:
+ ++ ::: <?> :->The Scala compiler will internally "mangle" operator identifiers to turn them into legal Java identifiers
with embedded $ characters. For instance, the identifier :-> would be represented internally
as $colon$minus$greater. If you ever wanted to access this identifier from Java code, you'd need to use
this internal representation.
Because operator identifiers in Scala can become arbitrarily long, there is a small difference between
Java and Scala. In Java, the input x<-y would be parsed as four lexical symbols, so it would be
equivalent to x < - y. In Scala, <- would be parsed as a single identifier, giving x <- y. If you want the
first interpretation, you need to separate the < and the - characters by a space. This is unlikely to be a
problem in practice, as very few people would write x<-y in Java without inserting spaces or
parentheses between the operators.
A mixed identifier consists of an alphanumeric identifier, which is followed by an underscore and an
operator identifier. For example, unary_+ used as a method name defines a unary +operator.
Or, myvar_= used as method name defines an assignment operator. In addition, the mixed identifier
form myvar_= is generated by the Scala compiler to support properties (more on that in Chapter 18).
A literal identifier is an arbitrary string enclosed in back ticks (` ...`). Some examples of literal
identifiers are:
`x` `<clinit>` `yield`
The idea is that you can put any string that's accepted by the runtime as an identifier between back
ticks. The result is always a Scala identifier. This works even if the name contained in the back ticks
would be a Scala reserved word. A typical use case is accessing the static yieldmethod in
Java's Thread class. You cannot write Thread.yield() because yield is a reserved word in Scala.
However, you can still name the method in back ticks, e.g., Thread.`yield`().

## 6.11 method overloading
方法重载，规则和Java类似    

## 6.12 implicit coversion
隐身转换：把一种数据类型转换成另外一种数据类型

```
val oneHalf = new Rational(1,2)
val oneThree = new Rational(1,3)
println(oneHalf * 2)

implicit def intToRational(x: Int) = new Rational(x) //函数的定义要在使用前定义 define it directly in
the interpreter
//函数的名称没有限制 
println(2 * oneHalf)
```

## 6.13 a word of cation
写代码不要滥用操作符和隐式转换，要把握度，以可读性为最高标准


# Build-in control construction
介绍控制语句逻辑 if while case for 等。 逻辑控制语句都是带有返回值得在scala中。

## 7.1  IF expression
if 表达式是有返回值的

```
val name = if(!args.isEmpty) args(0) else "default.txt"
println(name)
print(if(!args.isEmpty) args(0) else "default.txt") //if 表达式返回 args(0) 或者 default.txt


```
有一个规则使用val定义变量，在任何用到val定义变量的地方都可以使用对于的表达式。如上代码块

## 7.2 while looping
while looping is not a expression will not return any value.
不建议使用while 如果你有替代的方案，因为经常while和var会伴随出现。while 不同于if，没有返回值，返回值是Unit。

在scala中另外一个表达式也返回Unit就是等号复制语句。例如： name = "bill"

## 7.3 For expressions
for 表达式非常有用，在for表达式中可以添加判断条件if，可以加多个，也直接定义变量，不用关键字val。for表达式中的变量默认是val的。
```
val filesHere = (new File(".")).listFiles()

  def fileLines(file: java.io.File) = scala.io.Source.fromFile(file).getLines().toList

  def grep(pattern: String) = {
    for {file <- filesHere  //可以用小括号( ，也可以{ 为啥？ 不清楚
         if file isFile 
         if file.getName.endsWith("scala"); // 多个if判断这里的分号可以不加
         line <- fileLines(file)
         trimmedLine = line.trim  //直接定义变量，不用val关键字
         if trimmedLine.matches(pattern)
    } print(file + ":" + trimmedLine)
  }
  
  //yield的用法
  def sclaFiles = for {  
    file <- filesHere
    if file.getName.endsWith("scala")
  } yield file.getName
```
## match expressions
try match 和java类似，但是scala的try 表达式有返回值。 在finall中不建议使用return，因为finally中的return会覆盖try，match中的所有值。

```
object TryCatch {
  var name = 0

  def main(args: Array[String]): Unit = {
    println(f)
    println(g)
    println(h)

  }

  def f(): Int = try return 1 finally return 2
  def g(): Int = try 1 finally 2
  def h() = try name = 1 finally name = 2
}
输出值：
2
1
2
```
## variable scop
和java基本一样，只有一点差别，scala在签到的语句中可以定义相同的变量名称。

```
val a = 1;
{
val a = 2;
{
println(a)
}
}
```
